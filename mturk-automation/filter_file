"""
*** MUST READ ***
This function is to be ran from the command line.
Download this file, open your terminal and navigate to the directory it is saved in
and then run the following command:
'python filter_file' for windows
'python3 filter_file' for mac

You should be prompted with a file explorer window to select the dataframe that you want to fitler,
and then you will be prompted with another window requesting you to uncheck some boxes to get the desired dataframe
"""

from tkinter import *
from tkinter import Tk, filedialog
import pandas as pd
import random


root = Tk()


def create_test_set(fil_df):
    """
    This Function is for creating a big list of all the sentences that have been randomly selected
    to be apart of the test set for the classifier across all the labels. So it grabs about 20% of the sentences
    from each label and adds them to a list. This list is returned from this function.
    """

    # Getting all the unique labels from the dataframe
    labels = fil_df['top_label'].unique().tolist()

    # Creating the test set list
    test_set = []  # create big list that has all the sentences that are going to make the test set
    labels = fil_df['top_label'].unique().tolist()

    # Determine the number of sentences that need to be added to the test set for the specific label
    for label in labels:
        sentence_list = fil_df[fil_df['top_label'] == label]['Input.text'].tolist() # list of all sentences for that label
        count = len(sentence_list)
        test_amount = count * 0.2
        added = 0

        # randomly pick sentences from the sentence list to add the the test set
        while added <= test_amount:
            index = random.randint(0, count - 1)
            test_set.append(sentence_list[index])
            del sentence_list[index]
            added += 1
            count -= 1

    return test_set

def create_set_list(test_set, fil_df):
    """
    This function creates the list that is going to be appended to the dataframe to determine which specific sentences
    in the data frame are a part of the testing and training sets. When this list is added to the dataframe as a column
    called 'set' it is going to have a 1 in the row where that sentence in that row is a part of the test set
    and a 0 in the row where the sentence in that row is a part of the training set. It returns the filtered dataframe
    with this list appended on to it with the column label 'set' .
    """

    # Create a list of 0's
    set_list = []
    sentences = fil_df['Input.text'].tolist()
    for i in range(len(fil_df['top_label'])):
        set_list.append(0)

    # put a 1 in the row where a testing sentence is
    for sentence in test_set:
        index = sentences.index(sentence)
        set_list[index] = 1

    # add the testing and training list to the dataframe
    fil_df['set'] = set_list

    return fil_df

def add_label_code(new_df):
    """
    This function creates a list where it represents the labels in integers instead of strings.
    The function appends this list to the dataframe as a column named, 'class'. This function returns the filtered
    dataframe with the 'class' list column appended to it.
    """

    # Get the list of unique labels to create numerical key for
    labels = new_df['top_label'].unique().tolist()

    # create a dictionary that holds a value for each label
    key_dict = {}
    for i in range(len(labels)):
        key_dict[labels[i]] = i

    # create a list that is going to represent each label as the value from the dictionary
    Class = []
    for label in new_df['top_label']:
        Class.append(key_dict[label])

    # add the column to the dataframe
    new_df['class'] = Class

    return new_df

def add_binary_columns(fil_df):
    """
    This function adds several columns to the dataframe. For each unique label present in the 'top_label' column
    of the dataframe, there is a column added to the dataframe that has a '1' in the row where the label in the 'top_label'
    column of the label for that column. For example, for the 'work_binary' column, the column that was generated
    by this function because the label 'Work' was present in the 'top_label' column, this column would have a 1
    at each row where the label in the same row under the 'top_label' column was also 'Work' and would have 0's
    everywhere else. This function returns the filtered dataframe with all of these columns for each unique label
    appened to it.
    """

    # create a list of the unique labels
    labels = fil_df['top_label'].unique().tolist()

    # Create a list that marks each index that label is present with a 1
    for label in labels:
        temp_list = [0 for x in range(len(fil_df['Input.text']))]
        for i in range(len(fil_df['top_label'])):
            top = fil_df['top_label'].tolist()[i]
            if top == label:
                temp_list[i] = 1

        # Add the list to the dataframe
        fil_df[str(label) + '_' + 'binary'] = temp_list

    return fil_df


def file_selection():
    """
    This function creates the file selection GUI with the user to get the dataframe that is in needed of filtering.
    It returns a dataframe with all of the duplicate sentences removed and the values in the dataframe scrambled.
    """

    # Creating instance of the file selection GUI
    root.filename = filedialog.askopenfilename()
    file = root.filename
    df = pd.read_csv(file)

    # drop the duplicate sentences
    df.drop_duplicates(subset='Input.text', keep='first', inplace=True)

    # mix the df by a random sequence of numbers
    for i in range(5):
        random_list = random.sample(range(len(df['Input.text'])), len(df['Input.text']))
        df['scramble_seq'] = random_list  # add the list to the dataframe
        df = df.sort_values(by='scramble_seq')

    # drop the random number sequence column that scrambles
    df.drop(columns=['scramble_seq'], inplace=True)  # drop the column used to scramble data
    df.reset_index(drop=True, inplace=True)  # reset the index

    return df

def save_csv(df):
    """
    This function takes in the final dataframe after all the filtering and column appending
    and saves it to the directory where you have this code saved.
    """
    pd.DataFrame(df).to_csv("Filtered_df.csv", index=False, header=True)


def filter(df, dict):
    """
    This function does the filtering of the dataframe. It returns the dataframe with the items
    that the user chose to keep.
    """

    # loop through each value of the checkbutton
    for key in dict:
        for value in dict[key]:
            if dict[key][value].get() == 0:
                if value == 'is_stressor' or value == 'is_covid':
                    value = int(value)

                # keep everythiing in df except for the checkbuttons that were unselected
                df = df[df[key] != value]

    return df

def make_checkbox(column, name, dict):
    """
    This function creates the checkbutton for each unique value in a column of the dataframe.
    """

    # Creates checknbutton on GUI display
    Checkbutton(root, text=str(name), variable=dict[column][name]).pack()

def check_box(df):
    """
    This function creates the display for where the checkbuttons will appear and grabs the unique values
    for each of the columns to create a checkbutton for. This function returns a dictionary
    that holds all the values for the checkbuttons.
    """

    # size of display
    root.geometry('400x400')
    Label(root, bg='green', text="Please Unselect What you Don't Want included").pack() # message at top of display
    grand_dict = {} # initialize dictionary
    columns = df.columns.tolist() # get list of unique columns

    # selected most important columns for now
    for selector in columns[2:6]:
        grand_dict[selector] = {}

    # Creating all the checkboxes to be displayed on the Checkbutton GUI
    for name in grand_dict:
        list_items = df[name].unique().tolist()
        Label(root, bg='white', text=str(name)).pack()
        for item in list_items:
            grand_dict[name][item] = IntVar(value=1)
            make_checkbox(name, item, grand_dict)

    # create an exit button
    Button(root, text='Done', command=root.quit).pack()
    root.mainloop() # Necessary to display GUI
    root.withdraw() # Exits GUI

    return grand_dict


def main():
    """
    This function run all the code in the neccessary order.
    """
    df_o = file_selection()
    dictionary = check_box(df_o)
    fil_df = filter(df_o, dictionary)
    test_set = create_test_set(fil_df)
    set_df = create_set_list(test_set, fil_df)
    class_df = add_label_code(set_df)
    final_df = add_binary_columns(class_df)
    save_csv(final_df)

if __name__ == '__main__':
    main()